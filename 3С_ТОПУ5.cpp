#include <iostream>
#include <iomanip>
using namespace std;

const int i = 2;		//колличество переменных
const int j = i + 1;	//колличество вершин
double л = 0.1;
//-----------------------------------ФУЕКЦИИ



double F1(double x[2]) {
	if (x[0] * x[0] - x[1] + 2 <= 0)
		return 0;
	else
		return ((x[0] * x[0] - x[1] + 2) * (x[0] * x[0] - x[1] + 2));
}
double F2(double x[2]) {
	if (x[0] + x[1] <= 6)
		return 0;
	else
		return ((x[0] + x[1] - 6) * (x[0] + x[1] - 6));
}
double F3(double x[2]) {
	if (x[0] > 0)
		return 0;
	else
		return (x[0] * x[0]);
}
double F4(double x[2]) {
	if (x[1] > 0)
		return 0;
	else
		return (x[1] * x[1]);
}
//        x* = (1.5615528128088;4.4384471871912)     f(x*) = 5.2
double F(double x[2]) { return (4 * x[0] * x[0] - 5 * x[0] * x[1] + x[1] * x[1] + л * (F1(x) + F2(x) + F3(x) + F4(x))); }
//        x* = (0;2)     f(x*) = 4
//double F(double x[2]) { return (x[0] * x[0] + x[1] * x[1] + л * (F1(x) + F2(x) + F3(x) + F4(x)));}
//----------------------------------------------------------------------------------//

//-------------УСЛОВИЕ ОСТАНОВКИ (ДИСПЕРСИЯ)
double D(double xh[2], double xg[2], double xl[2], double xc[2])
{
	return sqrt(1 / (j + 1) * ((F(xh)) - F(xc)) * ((F(xh)) - F(xc)) + ((F(xg)) - F(xc)) * ((F(xg)) - F(xc)) + ((F(xl)) - F(xc)) * ((F(xl)) - F(xc)));
}


void сорт(double x[j][i]);
void мин(double x[2]);

int main() {
	double Eps = 0.000001;				//точность
	cout << char(218) << setfill(char(196)) << setw(4);
	cout << char(194) << setfill(char(196)) << setw(10);
	for (int i = 0; i < 5; i++)
	{
		cout << char(194) << setfill(char(196)) << setw(22);
	}
	cout << char(191) << endl;
	cout<< char(179) << " k "
		<< char(179) << "   a(k)  "
		<< char(179) << "   X(k+1) = X(a(k))  "
		<< char(179) << "      f(X(k+1))      "
		<< char(179) << "         g(x)        "
		<< char(179) << "           B         "
		<< char(179) << "        a(k)g(x)     "
		<< char(179) << endl;
	double x[i] = { -10,5 };
	double b = 10;
	int k = 0;
	while (л * (F1(x) + F2(x) + F3(x) + F4(x)) > Eps)
	{
		мин(x);
		cout << char(195) << setfill(char(196)) << setw(4);
		cout << char(197) << setfill(char(196)) << setw(10);
		for (int i = 0; i < 5; i++)
		{
			cout << char(197) << setfill(char(196)) << setw(22);
		}
		cout << char(180) << endl;

		cout << char(179) << " " << k << " ";
		cout << char(179) << " " << setfill(char(32)) << setw(7) << л << " ";
		cout << char(179) << " (" << setfill(char(32)) << setw(7) << round(x[0] * 1000) / 1000 << " ; " << left << setfill(char(32)) << setw(7) << round(x[1] * 1000) / 1000 << right << ") ";
		cout << char(179) << "    " << setfill(char(32)) << setw(11) << F(x) << "      ";
		cout << char(179) << "    " << setfill(char(32) )<< setw(11) << (F1(x) + F2(x) + F3(x) + F4(x)) << "      ";
		cout << char(179) << "        " << setfill(char(32)) << setw(5) << b << "        ";
		cout << char(179) << "    " << setfill(char(32)) << setw(11) << л * (F1(x) + F2(x) + F3(x) + F4(x)) << "      ";
		cout << char(179) << endl;

		л = л * b;
		k++;
	}
	cout << char(192) << setfill(char(196)) << setw(4);
	cout << char(193) << setfill(char(196)) << setw(10);
	for (int i = 0; i < 5; i++)
	{
		cout << char(193) << setfill(char(196)) << setw(22);
	}
	cout << char(217) << endl;
	system("PAUSE");

}



void мин(double x1[2]) {
	system("color F0");				//фон белый буквы черные
	int n;							//индексная переменная
	int k = 0;						//количество итераций
	bool f = 0;						//вспомогательный флаг
	double Temp[i];					//обменная переменная

	double Eps = 0.001;				//точность
	double	a = 1;					//коэфицент отражения
	double	b = 0.5;				//коэфицент сжатия
	double	y = 2;					//коэфицент рястяжения
	//начальный набор точек

	double	х_наиб[2];			//точка с наибольшем значением функции
	double	х_2_по_велечене[2];	//точка с 2 по велечине значением функции
	double	х_наим[2];			//точка с самым маленьким значением функции

	double	центр_тяж[2];		//центр тяжести
	double	отр[2];				//отраженный х
	double	отр_рас[2];			//отраженный х c растяжением
	double	отр_сжат[2];		//отраженный х с жатеем

	double	x[j][i] = { {x1[0],x1[1]},{ x1[0]+3,x1[1]+2 },{ x1[0]-3,x1[1]+2 } };
	do {
		k++;
		сорт(x);	//сортировка точек
		for (n = 0; n < i; n++)
		{
			центр_тяж[n] = 0;
			отр[n] = 0;
			отр_рас[n] = 0;
			отр_сжат[n] = 0;
			х_наиб[n] = x[i][n];
			х_2_по_велечене[n] = x[i - 1][n];
			х_наим[n] = x[0][n];
		}
		f = 0;

		//поиск центра тяжести
		for (n = 0; n < i; n++)
			for (int m = 0; m < i; m++)
				центр_тяж[n] = центр_тяж[n] + (x[m][n]);
		центр_тяж[0] = центр_тяж[0] / i; центр_тяж[1] = центр_тяж[1] / i;

		for (n = 0; n < i; n++)
			отр[n] = центр_тяж[n] + a * (центр_тяж[n] - х_наиб[n]);

		if (F(отр) <= F(х_наим))
		{
			for (n = 0; n < i; n++)
				отр_рас[n] = центр_тяж[n] + y * (отр[n] - центр_тяж[n]);
			double x7 = F(отр_рас);

			if (F(отр_рас) < F(отр))
				for (n = 0; n < i; n++)
					х_наиб[n] = отр_рас[n];
			else
				for (n = 0; n < i; n++)
					х_наиб[n] = отр[n];
		}
		else if (F(х_наим) <= F(отр) && F(отр) <= F(х_2_по_велечене))
		{
			for (n = 0; n < i; n++)
				х_наиб[n] = отр[n];
		}
		else if (F(х_2_по_велечене) <= F(отр) && F(отр) <= F(х_наиб))
		{
			for (n = 0; n < i; n++)
			{
				Temp[n] = отр[n];
				отр[n] = х_наиб[n];
				х_наиб[n] = Temp[n];
				f = 1;
			}
		}
		else if (F(х_наиб) <= F(отр))
			f = 1;
		if (f) {
			for (n = 0; n < i; n++)
				отр_сжат[n] = центр_тяж[n] + b * (х_наиб[n] - центр_тяж[n]);

			if (F(отр_сжат) < F(х_наиб))
				for (n = 0; n < i; n++)
					х_наиб[n] = отр_сжат[n];

			if (F(отр_сжат) >= F(х_наиб))
			{
				for (n = 0; n < i; n++)
				{
					x[i][n] = х_наиб[n];
					x[i - 1][n] = х_2_по_велечене[n];
					x[0][n] = х_наим[n];
				}
				сорт(x);	//сортировка точек
				for (n = 0; n < i; n++)
				{
					х_наиб[n] = x[i][n];
					х_2_по_велечене[n] = x[i - 1][n];
					х_наим[n] = x[0][n];
				}
				for (n = 0; n < i; n++)
				{
					х_наиб[n] = (х_наиб[n] + х_наим[n]) / 2;
					х_2_по_велечене[n] = (х_2_по_велечене[n] + х_наим[n]) / 2;
				}
			}
		}
		for (n = 0; n < i; n++)
		{
			x[i][n] = х_наиб[n];
			x[i - 1][n] = х_2_по_велечене[n];
			x[0][n] = х_наим[n];
		}

		//Таблица(x, х_наим, х_2_по_велечене, х_наиб, центр_тяж, отр, отр_рас, отр_сжат, k);

	} while (fabs(D(х_наиб, х_2_по_велечене, х_наим, центр_тяж)) > Eps);

	сорт(x);	//сортировка точек
	for (n = 0; n < i; n++)
		x1[n] = х_наим[n];
}

void сорт(double x[j][i])
{
	double Min;                	//минимальный элемент
	int jMin;					//индекс минимального элемента
	int iSort;					//граница отсортированной области
	int k;						//индексная переменная
	double Temp[i];				//обменная переменная

	for (iSort = 0; iSort < j - 1; iSort++)
	{
		//первый элемент из неупорядоченных назначаем минимальным
		Min = F(x[iSort]);				//минимум
		jMin = iSort;					//его индекс

		//ищем минимальный элемент в оставшейся части массива
		for (k = iSort + 1; k < j; k++)
		{
			if (F(x[k]) < Min)		//очередной кандидат на минимальный
			{
				//запоминаем минимальный элемент и его номер
				Min = F(x[k]);
				jMin = k;
			}//if

		}//for j

		//нашли минимум в неупорядоченной части массива
		//ставим его на место первого в неупорядоченной части массива
		//меняем элементы местами
		for (k = 0; k < i; k++)
		{
			Temp[k] = x[iSort][k];
			x[iSort][k] = x[jMin][k];
			x[jMin][k] = Temp[k];
		}
	} //for iSort
}